<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Progress Tracker</title>
  <link rel="manifest" href="manifest.json">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Progress Tracker</h1>

  <div class="add-goal-section">
    <h2>Add New Goal</h2>
    <label>New Goal Name: <input type="text" id="newName"></label>
    <span class="error-message" id="error-newName"></span><br>

    <label>Goal Type:
        <select id="newGoalType" onchange="toggleGoalTypeFields()">
            <option value="numeric">Numeric (e.g., read X pages)</option>
            <option value="boolean">To-Do (e.g., finish a task)</option>
        </select>
    </label><br>

    <div id="numericGoalFields">
        <label>Target: <input type="number" id="newTarget"></label>
        <span class="error-message" id="error-newTarget"></span><br>
        <label>Unit (optional): <input type="text" id="newUnit" placeholder="e.g., pages, km, hours"></label><br>
    </div>

    <label>Category:
      <div id="categorySelectContainer" style="display: flex; flex-wrap: wrap; align-items: center;">
          <select id="newCategory" style="flex-grow: 1; max-width: 250px; margin-right: 10px;"></select>
          <button onclick="addCustomCategory()">Add Custom Category</button>
      </div>
    </label><br>
    
    <label>Due Date (optional): <input type="date" id="newDueDate"></label><br>

    <button onclick="addGoal()">Add Goal</button>
  </div>

  <div id="manageCategorySection" class="add-goal-section">
      <h2>Manage Categories</h2>
      <div id="categoryList"></div>
  </div>

  <div class="filter-sort-section">
    <h2>Filter & Sort Goals</h2>
    <label>Filter by Category:
      <select id="filterCategory" onchange="renderGoals()">
        <option value="all">All</option>
      </select>
    </label>
    <label>Sort by:
      <select id="sortBy" onchange="renderGoals()">
        <option value="name">Name</option>
        <option value="progressAsc">Progress (Asc)</option>
        <option value="progressDesc">Progress (Desc)</option>
        <option value="creationDate">Creation Date</option>
        <option value="dueDate">Due Date</option>
      </select>
    </label>
    <label>Search: <input type="text" id="searchGoals" onkeyup="renderGoals()" placeholder="Search goals..."></label>
  </div>

  <div id="goalsContainer"></div>

  <div class="utility-buttons">
    <button onclick="toggleDarkMode()">Toggle Dark Mode</button>
    <button onclick="exportGoals()">Export Goals</button>
    <input type="file" accept=".json" onchange="importGoals(event)">
  </div>

  <div id="toastNotification" class="toast-notification"></div>
  <div id="undoNotification" class="undo-notification">
    Action undone! <button onclick="confirmUndo()">Confirm</button>
  </div>


  <script>
    let goals = [];
    let categories = ['Sport', 'Work', 'Personal', 'Other']; // Default categories
    let previousGoalsState = null;
    let undoTimeout = null;

    function loadGoals() {
      const savedGoals = localStorage.getItem('goals');
      if (savedGoals) {
        goals = JSON.parse(savedGoals);
      }
      const savedCategories = localStorage.getItem('categories');
      if (savedCategories) {
        categories = JSON.parse(savedCategories);
      }
      populateCategories();
      populateFilterCategories();
      renderGoals();
    }

    function saveGoals() {
      localStorage.setItem('goals', JSON.stringify(goals));
    }

    function saveCategories() {
      localStorage.setItem('categories', JSON.stringify(categories));
    }

    function populateCategories() {
      const selectElement = document.getElementById('newCategory');
      selectElement.innerHTML = ''; // Clear existing options
      categories.forEach(category => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        selectElement.appendChild(option);
      });
      addCategoryDeleteButtons(); // Add delete buttons after populating
    }

    function populateFilterCategories() {
      const filterSelectElement = document.getElementById('filterCategory');
      filterSelectElement.innerHTML = '<option value="all">All</option>'; // Always include "All"
      categories.forEach(category => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        filterSelectElement.appendChild(option);
      });
    }

    function addCategoryDeleteButtons() {
        // Let's create a dedicated section for managing categories below the add goal section
        let manageCategorySection = document.getElementById('manageCategorySection');
        if (!manageCategorySection) { // Should already exist from HTML, but just in case
            manageCategorySection = document.createElement('div');
            manageCategorySection.id = 'manageCategorySection';
            manageCategorySection.className = 'add-goal-section'; // Reuse styling
            manageCategorySection.innerHTML = `
                <h2>Manage Categories</h2>
                <div id="categoryList"></div>
            `;
            // This line would typically be where you want to insert it in the DOM
            // For now, it's defined directly in the HTML.
            // document.querySelector('.add-goal-section').after(manageCategorySection);
        }

        const categoryListDiv = document.getElementById('categoryList');
        categoryListDiv.innerHTML = ''; // Clear existing list

        categories.forEach(category => {
            // Do not show delete button for default categories
            if (['Sport', 'Work', 'Personal', 'Other'].includes(category)) {
                categoryListDiv.innerHTML += `<div class="category-list-item"><span>${category}</span></div>`;
            } else {
                categoryListDiv.innerHTML += `
                    <div class="category-list-item">
                        <span>${category}</span>
                        <button class="delete-category-btn" onclick="deleteCategory('${category}')">&times;</button>
                    </div>
                `;
            }
        });
    }


    function deleteCategory(categoryToDelete) {
        if (['Sport', 'Work', 'Personal', 'Other'].includes(categoryToDelete)) {
            showToast('Default categories cannot be deleted.', 'warning');
            return;
        }

        if (confirm(`Are you sure you want to delete the category "${categoryToDelete}"? This will not delete goals, but their category will be marked as 'Other'.`)) {
            // Filter out the category from the main categories array
            categories = categories.filter(cat => cat !== categoryToDelete);
            saveCategories();

            // Update goals that used this category to 'Other'
            goals.forEach(goal => {
                if (goal.category === categoryToDelete) {
                    goal.category = 'Other';
                }
            });
            saveGoals();

            populateCategories(); // Re-populate select dropdown
            populateFilterCategories(); // Re-populate filter dropdown
            addCategoryDeleteButtons(); // Re-render the category management list
            renderGoals(); // Re-render goals to reflect category change
            showToast(`Category "${categoryToDelete}" deleted. Associated goals are now in 'Other' category.`, 'info');
        }
    }


    function showToast(message, type = 'success') {
      const toast = document.getElementById('toastNotification');
      toast.textContent = message;
      toast.className = `toast-notification ${type} show`;
      setTimeout(() => {
        toast.className = toast.className.replace('show', '');
      }, 3000); // Hide after 3 seconds
    }

    function showUndoNotification(actionFunction) {
        const undoNotification = document.getElementById('undoNotification');
        // Using a temporary state to indicate what was last undone (e.g., 'deleteGoal' or 'resetGoal')
        // We don't pass the actionFunction directly here, but simply offer to restore the previous state.
        undoNotification.className = 'undo-notification show';
        
        // Remove existing event listener to prevent multiple calls
        const undoButton = undoNotification.querySelector('button');
        if (undoButton) {
            undoButton.removeEventListener('click', confirmUndo);
            undoButton.addEventListener('click', confirmUndo);
        }

        clearTimeout(undoTimeout);
        undoTimeout = setTimeout(() => {
            hideUndoNotification();
        }, 5000); // Hide undo button after 5 seconds
    }

    function confirmUndo() {
        if (previousGoalsState) {
            goals = previousGoalsState;
            saveGoals();
            renderGoals();
            showToast('Action undone!', 'info');
            hideUndoNotification();
            previousGoalsState = null; // Clear state after undo
        }
    }

    function hideUndoNotification() {
        const undoNotification = document.getElementById('undoNotification');
        undoNotification.className = 'undo-notification';
        const undoButton = undoNotification.querySelector('button');
        if (undoButton) {
            undoButton.removeEventListener('click', confirmUndo); // Clean up listener
        }
    }

    // This is just a placeholder for visual effect. Real confetti needs more.
    function triggerConfetti(targetElement) {
        targetElement.classList.add('confetti-animation');
        setTimeout(() => {
            targetElement.classList.remove('confetti-animation');
        }, 1500); // Match animation duration
    }

    function validateForm() {
        let isValid = true;
        const nameInput = document.getElementById('newName');
        const targetInput = document.getElementById('newTarget');
        const nameError = document.getElementById('error-newName');
        const targetError = document.getElementById('error-newTarget');
        const goalType = document.getElementById('newGoalType').value;

        nameError.textContent = '';
        nameInput.classList.remove('is-invalid');
        targetError.textContent = '';
        targetInput.classList.remove('is-invalid');

        if (!nameInput.value.trim()) {
            nameError.textContent = 'Goal name cannot be empty.';
            nameInput.classList.add('is-invalid');
            isValid = false;
        }

        if (goalType === 'numeric') {
            const target = parseInt(targetInput.value);
            if (isNaN(target) || target <= 0) {
                targetError.textContent = 'Target must be a positive number.';
                targetInput.classList.add('is-invalid');
                isValid = false;
            }
        }
        // No validation needed for boolean type target as it's not present

        return isValid;
    }

    function addCustomCategory() {
      const customCategory = prompt("Enter new category name:");
      if (customCategory && customCategory.trim() !== '') {
        const trimmedCategory = customCategory.trim();
        if (!categories.includes(trimmedCategory)) {
          categories.push(trimmedCategory);
          saveCategories();
          populateCategories();
          populateFilterCategories();
          document.getElementById('newCategory').value = trimmedCategory; // Select the new category
          showToast(`Category "${trimmedCategory}" added!`, 'success');
        } else {
          showToast("Category already exists!", 'warning');
        }
      }
    }

    function addGoal() {
      if (!validateForm()) {
        showToast('Please correct the form errors.', 'error');
        return;
      }

      const name = document.getElementById('newName').value.trim();
      const targetInput = document.getElementById('newTarget');
      const unitInput = document.getElementById('newUnit');
      const category = document.getElementById('newCategory').value;
      const dueDate = document.getElementById('newDueDate').value;
      const goalType = document.getElementById('newGoalType').value;

      let goalData = {
          name,
          category,
          creationDate: new Date().toISOString(),
          dueDate: dueDate || null,
          type: goalType,
          reminderTime: null // Placeholder for future reminder UI
      };

      if (goalType === 'numeric') {
          goalData.target = parseInt(targetInput.value);
          goalData.current = 0;
          goalData.unit = unitInput.value.trim();
          goalData.history = [];
      } else { // boolean
          goalData.completed = false; // For boolean goals
          goalData.history = []; // History for toggles
      }

      goals.push(goalData);
      saveGoals();
      renderGoals();
      
      document.getElementById('newName').value = '';
      targetInput.value = '';
      unitInput.value = '';
      document.getElementById('newCategory').selectedIndex = 0;
      document.getElementById('newDueDate').value = '';
      document.getElementById('newGoalType').value = 'numeric'; // Reset to default
      toggleGoalTypeFields(); // Adjust fields for numeric
      showToast('Goal added successfully!', 'success');
    }

    function updateGoal(index) {
        previousGoalsState = JSON.parse(JSON.stringify(goals)); // Deep copy
        const goal = goals[index];
        if (goal.type === 'numeric') {
            const progressInput = document.getElementById(`progress-${index}`);
            const progress = parseInt(progressInput.value);
            if (!isNaN(progress) && progress !== 0) {
                goal.current += progress;
                if (goal.current > goal.target) {
                    goal.current = goal.target;
                }
                goal.history.push({ date: new Date().toLocaleString(), value: progress });
                saveGoals();
                renderGoals();
                progressInput.value = '';
                if (goal.current >= goal.target) {
                    const goalElement = document.querySelector(`.goal[data-index="${index}"]`);
                    if (goalElement) triggerConfetti(goalElement);
                    showToast(`Goal "${goal.name}" completed!`, 'success');
                }
            } else {
                showToast('Please enter a valid number for progress.', 'error');
            }
        } else { // boolean
            goal.completed = !goal.completed;
            goal.history.push({ date: new Date().toLocaleString(), value: goal.completed ? 'Completed' : 'Unchecked' });
            saveGoals();
            renderGoals();
            if (goal.completed) {
                const goalElement = document.querySelector(`.goal[data-index="${index}"]`);
                if (goalElement) triggerConfetti(goalElement);
                showToast(`Goal "${goal.name}" marked as completed!`, 'success');
            } else {
                showToast(`Goal "${goal.name}" marked as incomplete.`, 'info');
            }
        }
        showUndoNotification();
    }

    function resetGoal(index) {
      if (confirm('Are you sure you want to reset this goal\'s progress to zero?')) {
        previousGoalsState = JSON.parse(JSON.stringify(goals)); // Deep copy
        goals[index].current = 0;
        goals[index].history.push({ date: new Date().toLocaleString(), value: 'Reset' });
        saveGoals();
        renderGoals();
        showToast('Goal progress reset!', 'info');
        showUndoNotification();
      }
    }

    function editGoal(index) {
      previousGoalsState = JSON.parse(JSON.stringify(goals)); // Deep copy
      const goal = goals[index];
      const newName = prompt("Enter new name for " + goal.name + ":", goal.name);
      if (newName !== null && newName.trim() !== '') {
        goal.name = newName.trim();
      }

      if (goal.type === 'numeric') {
        const newTarget = prompt("Enter new target for " + goal.name + " (current: " + goal.target + "):", goal.target);
        if (newTarget !== null && !isNaN(parseInt(newTarget)) && parseInt(newTarget) > 0) {
          goal.target = parseInt(newTarget);
        }
        const newUnit = prompt("Enter new unit for " + goal.name + " (current: " + (goal.unit || '') + "):", goal.unit || '');
        if (newUnit !== null) {
            goal.unit = newUnit.trim();
        }
      } else { // boolean type - allow changing its completion state if needed from edit (less common)
          const newCompleted = confirm(`Mark "${goal.name}" as completed? Current state: ${goal.completed ? 'Completed' : 'Incomplete'}`);
          if (newCompleted !== goal.completed) {
              goal.completed = newCompleted;
              goal.history.push({ date: new Date().toLocaleString(), value: goal.completed ? 'Completed (via edit)' : 'Unchecked (via edit)' });
          }
      }

      const newCategory = prompt("Enter new category for " + goal.name + " (current: " + goal.category + "). Existing: " + categories.join(', ') + " or type new:", goal.category);
      if (newCategory !== null && newCategory.trim() !== '') {
        const trimmedCategory = newCategory.trim();
        if (!categories.includes(trimmedCategory)) {
          categories.push(trimmedCategory);
          saveCategories();
          populateCategories();
          populateFilterCategories();
        }
        goal.category = trimmedCategory;
      }
      
      const newDueDate = prompt("Enter new due date for " + goal.name + " (YYYY-MM-DD) (current: " + (goal.dueDate || 'None') + "):", goal.dueDate || '');
      goal.dueDate = newDueDate ? newDueDate : null;


      saveGoals();
      renderGoals();
      showToast('Goal updated!', 'info');
      showUndoNotification();
    }


    function deleteGoal(index) {
      if (confirm('Are you sure you want to delete this goal? This action cannot be undone.')) {
        previousGoalsState = JSON.parse(JSON.stringify(goals)); // Deep copy
        goals.splice(index, 1);
        saveGoals();
        renderGoals();
        showToast('Goal deleted!', 'warning');
        showUndoNotification();
      }
    }

    function renderGoals() {
      const container = document.getElementById('goalsContainer');
      container.innerHTML = '';

      let displayedGoals = [...goals]; // Create a copy to sort/filter

      // Filtering
      const filterCategory = document.getElementById('filterCategory').value;
      if (filterCategory !== 'all') {
        displayedGoals = displayedGoals.filter(goal => goal.category === filterCategory);
      }

      // Searching
      const searchTerm = document.getElementById('searchGoals').value.toLowerCase();
      if (searchTerm) {
        displayedGoals = displayedGoals.filter(goal =>
          goal.name.toLowerCase().includes(searchTerm) ||
          goal.category.toLowerCase().includes(searchTerm)
        );
      }

      // Sorting
      const sortBy = document.getElementById('sortBy').value;
      displayedGoals.sort((a, b) => {
        if (sortBy === 'name') {
          return a.name.localeCompare(b.name);
        } else if (sortBy === 'progressAsc') {
          // For boolean, treat completed as 1 and incomplete as 0 for sorting
          const valA = a.type === 'numeric' ? (a.current / a.target) : (a.completed ? 1 : 0);
          const valB = b.type === 'numeric' ? (b.current / b.target) : (b.completed ? 1 : 0);
          return valA - valB;
        } else if (sortBy === 'progressDesc') {
          const valA = a.type === 'numeric' ? (a.current / a.target) : (a.completed ? 1 : 0);
          const valB = b.type === 'numeric' ? (b.current / b.target) : (b.completed ? 1 : 0);
          return valB - valA;
        } else if (sortBy === 'creationDate') {
          return new Date(a.creationDate) - new Date(b.creationDate);
        } else if (sortBy === 'dueDate') {
            // Treat null due dates as very late
            const dateA = a.dueDate ? new Date(a.dueDate) : new Date('9999-12-31');
            const dateB = b.dueDate ? new Date(b.dueDate) : new Date('9999-12-31');
            return dateA - dateB;
        }
        return 0;
      });

      if (displayedGoals.length === 0) {
        container.innerHTML = '<p class="no-goals-message">No goals to display based on current filters/search.</p>';
        return;
      }

      displayedGoals.forEach((goal, index) => {
        // Find original index to ensure correct deletion/update
        const originalIndex = goals.findIndex(g => g.creationDate === goal.creationDate && g.name === goal.name);

        const goalDiv = document.createElement('div');
        goalDiv.className = 'goal';
        goalDiv.setAttribute('data-index', originalIndex); // For confetti

        let progressHtml = '';
        let statusText = '';
        let isCompleted = false;

        if (goal.type === 'numeric') {
            const percentage = (goal.current / goal.target) * 100;
            isCompleted = goal.current >= goal.target;
            statusText = isCompleted ? 'Completed!' : `${goal.current} / ${goal.target} ${goal.unit || ''} (${percentage.toFixed(1)}%)`;
            
            goalDiv.classList.toggle('completed-goal', isCompleted); // Add/remove completed class

            progressHtml = `
                <p>Progress: <span class="${isCompleted ? 'goal-completed-text' : ''}">${statusText}</span></p>
                <div class="progress-bar ${isCompleted ? 'completed-bar' : ''}"><div class="progress" style="width: ${percentage}%"></div></div>
                <label>Add progress: <input type="number" id="progress-${originalIndex}"></label>
                <button onclick="updateGoal(${originalIndex})">Update</button>
                <button onclick="resetGoal(${originalIndex})">Reset Progress</button>
            `;
        } else { // boolean
            isCompleted = goal.completed;
            statusText = isCompleted ? 'Completed' : 'Incomplete';

            goalDiv.classList.toggle('completed-goal', isCompleted); // Add/remove completed class

            progressHtml = `
                <p>Status: <span class="status-boolean ${isCompleted ? 'completed' : 'incomplete'}">${statusText}</span></p>
                <label class="checkbox-container">
                    <input type="checkbox" ${isCompleted ? 'checked' : ''} onchange="updateGoal(${originalIndex})"> Mark as ${isCompleted ? 'Incomplete' : 'Complete'}
                    <span class="checkmark"></span>
                </label>
            `;
        }

        let dueDateHtml = '';
        if (goal.dueDate) {
            const due = new Date(goal.dueDate + 'T23:59:59'); // Set to end of day for calculation
            const now = new Date();
            const timeLeft = Math.ceil((due - now) / (1000 * 60 * 60 * 24)); // Calculate days left
            let dueDateClass = '';
            let dueDateText = `Due: ${goal.dueDate}`;
            if (timeLeft < 0) {
                dueDateText += ` (Overdue by ${Math.abs(timeLeft)} days)`;
                dueDateClass = 'overdue';
            } else if (timeLeft <= 7 && timeLeft >= 0) { // Approaching, but not overdue
                dueDateText += ` (${timeLeft} days left)`;
                dueDateClass = 'approaching-due';
            } else {
                 dueDateText += ` (${timeLeft} days left)`; // Still show days left for future dates
            }
            dueDateHtml = `<p class="due-date ${dueDateClass}">${dueDateText}</p>`;
        }


        goalDiv.innerHTML = `
          <button class="delete-goal-btn" onclick="deleteGoal(${originalIndex})">&times;</button>
          <h3 class="${isCompleted && goal.type === 'numeric' ? 'goal-completed-text' : ''}">${goal.name} (${goal.category})</h3>
          ${dueDateHtml}
          ${progressHtml}
          <button onclick="editGoal(${originalIndex})">Edit Goal</button>
          <button onclick="toggleHistory(${originalIndex})">View History</button>
          <div class="history-display" id="history-display-${originalIndex}" style="display:none;"></div>

          <div class="reminder-section">
            <h4>Reminder</h4>
            <label>Set Reminder Time: <input type="time" id="reminder-time-${originalIndex}" value="${goal.reminderTime || ''}"></label>
            <button onclick="setGoalReminder(${originalIndex})">Set Reminder</button>
            <button onclick="clearGoalReminder(${originalIndex})">Clear Reminder</button>
          </div>
        `;
        container.appendChild(goalDiv);
      });
    }

    // Renamed from showHistory to toggleHistory
    function toggleHistory(index) {
      const goal = goals[index];
      const historyDisplay = document.getElementById(`history-display-${index}`);

      if (historyDisplay.style.display === 'none') {
        // Show history
        if (goal && goal.history && goal.history.length > 0) {
          historyDisplay.innerHTML = '<h4>Progress History:</h4><ul>' +
            goal.history.map(h => `<li>${h.date}: ${h.value}</li>`).join('') +
            '</ul>';
        } else {
          historyDisplay.innerHTML = '<p>No history available for this goal.</p>';
        }
        historyDisplay.style.display = 'block';
      } else {
        // Hide history
        historyDisplay.style.display = 'none';
        historyDisplay.innerHTML = ''; // Clear content when hidden (optional)
      }
    }

    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
    }

    // --- Reminder Functions ---
    // Note: These simple reminders only work while the browser tab is open.
    // For persistent notifications, a service worker with Push API (and a server) is needed.
    let goalReminders = {}; // Store active timeouts for reminders

    function setGoalReminder(index) {
        const goal = goals[index];
        const reminderTimeInput = document.getElementById(`reminder-time-${index}`);
        const timeValue = reminderTimeInput.value; // e.g., "14:30"

        if (!timeValue) {
            showToast('Please select a time for the reminder.', 'error');
            return;
        }

        // Request Notification permission if not already granted
        if (Notification.permission === 'denied') {
            showToast('Notification permission denied. Please enable it in your browser settings.', 'error');
            return;
        }
        if (Notification.permission !== 'granted') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    setGoalReminderLogic(index, goal, timeValue);
                } else {
                    showToast('Notification permission not granted. Cannot set reminder.', 'error');
                }
            });
        } else {
            setGoalReminderLogic(index, goal, timeValue);
        }
    }

    function setGoalReminderLogic(index, goal, timeValue) {
        clearGoalReminder(index); // Clear any existing reminder for this goal

        const [hours, minutes] = timeValue.split(':').map(Number);
        const now = new Date();
        let targetDate = new Date();
        targetDate.setHours(hours, minutes, 0, 0);

        // If target time is in the past for today, schedule for tomorrow
        if (targetDate.getTime() <= now.getTime()) {
            targetDate.setDate(targetDate.getDate() + 1);
        }

        const delay = targetDate.getTime() - now.getTime();

        goal.reminderTime = timeValue; // Store reminder time in goal object
        saveGoals(); // Persist the reminder time preference

        const timeoutId = setTimeout(() => {
            new Notification('Progress Tracker Reminder', {
                body: `Time to update your progress for: "${goal.name}"!`,
                icon: 'icon-192.png'
            });
            // After first notification, set up daily repetition
            goalReminders[index] = setInterval(() => {
                new Notification('Progress Tracker Reminder', {
                    body: `Time to update your progress for: "${goal.name}"!`,
                    icon: 'icon-192.png'
                });
            }, 24 * 60 * 60 * 1000); // Daily
        }, delay);

        goalReminders[index] = timeoutId; // Store the initial timeout ID
        showToast(`Reminder set for "${goal.name}" at ${timeValue}.`, 'success');
    }

    function clearGoalReminder(index) {
        if (goalReminders[index]) {
            clearTimeout(goalReminders[index]); // Clear initial timeout
            clearInterval(goalReminders[index]); // Clear interval if already running
            delete goalReminders[index];
            goals[index].reminderTime = null; // Remove reminder time from goal
            saveGoals();
            showToast(`Reminder cleared for "${goals[index].name}".`, 'info');
            const reminderTimeInput = document.getElementById(`reminder-time-${index}`);
            if(reminderTimeInput) reminderTimeInput.value = ''; // Clear UI input
        } else {
            showToast('No active reminder found for this goal.', 'warning');
        }
    }
    // --- End Reminder Functions ---

    function exportGoals() {
      const dataToExport = {
        goals: goals,
        categories: categories
      };
      const data = JSON.stringify(dataToExport, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'progress_tracker_data.json';
      a.click();
      URL.revokeObjectURL(url);
      showToast('Goals exported successfully!', 'success');
    }

    function importGoals(event) {
      const file = event.target.files[0];
      if (!file) {
        showToast('No file selected for import.', 'error');
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const importedData = JSON.parse(e.target.result);
          if (importedData && importedData.goals && Array.isArray(importedData.goals)) {
            goals = importedData.goals;
            if (importedData.categories && Array.isArray(importedData.categories)) {
              categories = importedData.categories;
              saveCategories();
              populateCategories();
              populateFilterCategories();
            }
            saveGoals();
            renderGoals();
            showToast('Goals imported successfully!', 'success');
          } else {
            showToast('Invalid JSON file format. Please import a JSON object with a "goals" array and optionally a "categories" array.', 'error');
          }
        } catch (error) {
          showToast('Error importing goals: ' + error.message, 'error');
          console.error('Import error:', error);
        }
      };
      reader.readAsText(file);
    }

    function toggleGoalTypeFields() {
        const goalType = document.getElementById('newGoalType').value;
        const numericFields = document.getElementById('numericGoalFields');
        if (goalType === 'numeric') {
            numericFields.style.display = 'block';
        } else {
            numericFields.style.display = 'none';
        }
    }


    // Initial setup on page load
    loadGoals();
    toggleGoalTypeFields(); // Set initial visibility for goal type fields

    // Load dark mode preference
    if (localStorage.getItem('darkMode') === 'true') {
      document.body.classList.add('dark-mode');
    }

    // Service Worker registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
          .then(registration => {
            console.log('Service Worker registered with scope:', registration.scope);
          })
          .catch(error => {
            console.error('Service Worker registration failed:', error);
          });
      });
    }
  </script>
</body>
</html>